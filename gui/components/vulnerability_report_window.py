"""
SMBSeek GUI - Vulnerability Report Window

Comprehensive vulnerability analysis and reporting interface with export capabilities.
Provides filtered views of security findings with detailed remediation guidance.

Design Decision: Dedicated vulnerability report window allows security teams to focus
on critical findings while providing export capabilities for team collaboration.
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import csv
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Callable
import sys
import os

# Add utils to path
gui_dir = Path(__file__).parent.parent
sys.path.insert(0, str(gui_dir / "utils"))

from style import get_theme


def open_vulnerability_report_window(parent: tk.Tk, db_reader, data: Dict[str, Any]) -> None:
    """
    Open vulnerability report window.
    
    Args:
        parent: Parent window
        db_reader: Database reader instance
        data: Context data for the report
    """
    window = VulnerabilityReportWindow(parent, db_reader, data)


class VulnerabilityReportWindow:
    """
    Vulnerability Report Window for detailed security analysis.
    
    Provides comprehensive vulnerability reporting with filtering, sorting,
    and export capabilities. Supports both simple and advanced viewing modes.
    """
    
    def __init__(self, parent: tk.Tk, db_reader, data: Dict[str, Any]):
        """
        Initialize vulnerability report window.
        
        Args:
            parent: Parent window
            db_reader: Database reader instance  
            data: Context data for filtering reports
        """
        self.parent = parent
        self.db_reader = db_reader
        self.context_data = data
        self.theme = get_theme()
        
        # Window state
        self.window = None
        self.vulnerabilities = []
        self.filtered_vulnerabilities = []
        self.simple_mode = True
        
        # UI components
        self.tree = None
        self.filter_frame = None
        self.advanced_frame = None
        self.status_label = None
        self.mode_button = None
        
        # Filter variables
        self.filter_vars = {
            'severity': tk.StringVar(),
            'status': tk.StringVar(),
            'vulnerability_type': tk.StringVar(),
            'date_from': tk.StringVar(),
            'date_to': tk.StringVar()
        }
        
        self._create_window()
        self._load_vulnerabilities()
        self._apply_filters()
    
    def _create_window(self) -> None:
        """Create and configure the vulnerability report window."""
        self.window = tk.Toplevel(self.parent)
        self.window.title("SMBSeek - Vulnerability Report")
        self.window.geometry("1000x700")
        self.window.minsize(800, 600)
        
        # Apply theme
        self.theme.apply_to_widget(self.window, "main_window")
        
        # Configure window behavior
        self.window.transient(self.parent)
        self.window.grab_set()
        
        # Create main layout
        self._create_toolbar()
        self._create_filter_panel()
        self._create_vulnerability_tree()
        self._create_status_bar()
        
        # Setup keyboard shortcuts
        self._setup_shortcuts()
        
        # Center window
        self._center_window()
    
    def _create_toolbar(self) -> None:
        """Create toolbar with actions and mode toggle."""
        toolbar_frame = tk.Frame(self.window)
        toolbar_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Title
        title_label = self.theme.create_styled_label(
            toolbar_frame, 
            "ðŸ”´ Vulnerability Report", 
            "heading"
        )
        title_label.pack(side=tk.LEFT)
        
        # Right side buttons
        right_frame = tk.Frame(toolbar_frame)
        right_frame.pack(side=tk.RIGHT)
        
        # Mode toggle button
        self.mode_button = tk.Button(
            right_frame,
            text="Advanced Mode",
            command=self._toggle_mode
        )
        self.theme.apply_to_widget(self.mode_button, "button_secondary")
        self.mode_button.pack(side=tk.LEFT, padx=(0, 5))
        
        # Export button
        export_button = tk.Button(
            right_frame,
            text="ðŸ“Š Export",
            command=self._show_export_menu
        )
        self.theme.apply_to_widget(export_button, "button_primary")
        export_button.pack(side=tk.LEFT, padx=(0, 5))
        
        # Refresh button
        refresh_button = tk.Button(
            right_frame,
            text="ðŸ”„ Refresh",
            command=self._refresh_data
        )
        self.theme.apply_to_widget(refresh_button, "button_secondary")
        refresh_button.pack(side=tk.LEFT)
    
    def _create_filter_panel(self) -> None:
        """Create filtering panel."""
        self.filter_frame = tk.LabelFrame(self.window, text="Filters")
        self.filter_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Simple mode filters (always visible)
        simple_frame = tk.Frame(self.filter_frame)
        simple_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Severity filter
        tk.Label(simple_frame, text="Severity:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
        severity_combo = ttk.Combobox(
            simple_frame, 
            textvariable=self.filter_vars['severity'],
            values=['All', 'Critical', 'High', 'Medium', 'Low'],
            width=12
        )
        severity_combo.set('All')
        severity_combo.grid(row=0, column=1, padx=(0, 15))
        severity_combo.bind('<<ComboboxSelected>>', self._on_filter_change)
        
        # Status filter
        tk.Label(simple_frame, text="Status:").grid(row=0, column=2, sticky=tk.W, padx=(0, 5))
        status_combo = ttk.Combobox(
            simple_frame,
            textvariable=self.filter_vars['status'], 
            values=['All', 'Open', 'Investigating', 'False Positive', 'Fixed'],
            width=12
        )
        status_combo.set('All')
        status_combo.grid(row=0, column=3, padx=(0, 15))
        status_combo.bind('<<ComboboxSelected>>', self._on_filter_change)
        
        # Quick filter buttons
        button_frame = tk.Frame(simple_frame)
        button_frame.grid(row=0, column=4, padx=(15, 0))
        
        tk.Button(
            button_frame, text="Critical Only", 
            command=lambda: self._apply_quick_filter('Critical')
        ).pack(side=tk.LEFT, padx=2)
        
        tk.Button(
            button_frame, text="Open Issues", 
            command=lambda: self._apply_quick_filter('Open')
        ).pack(side=tk.LEFT, padx=2)
        
        tk.Button(
            button_frame, text="Clear Filters", 
            command=self._clear_filters
        ).pack(side=tk.LEFT, padx=2)
        
        # Advanced filters (initially hidden)
        self.advanced_frame = tk.Frame(self.filter_frame)
        
        # Vulnerability type filter
        tk.Label(self.advanced_frame, text="Type:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
        type_combo = ttk.Combobox(
            self.advanced_frame,
            textvariable=self.filter_vars['vulnerability_type'],
            values=['All', 'Authentication', 'Authorization', 'Information Disclosure', 'Misconfiguration'],
            width=15
        )
        type_combo.set('All')
        type_combo.grid(row=0, column=1, padx=(0, 15))
        type_combo.bind('<<ComboboxSelected>>', self._on_filter_change)
        
        # Date range filters
        tk.Label(self.advanced_frame, text="From:").grid(row=0, column=2, sticky=tk.W, padx=(0, 5))
        date_from_entry = tk.Entry(self.advanced_frame, textvariable=self.filter_vars['date_from'], width=12)
        date_from_entry.grid(row=0, column=3, padx=(0, 10))
        
        tk.Label(self.advanced_frame, text="To:").grid(row=0, column=4, sticky=tk.W, padx=(0, 5))
        date_to_entry = tk.Entry(self.advanced_frame, textvariable=self.filter_vars['date_to'], width=12)
        date_to_entry.grid(row=0, column=5)
        
        # Bind date filter changes
        date_from_entry.bind('<KeyRelease>', self._on_filter_change)
        date_to_entry.bind('<KeyRelease>', self._on_filter_change)
    
    def _create_vulnerability_tree(self) -> None:
        """Create vulnerability list tree view."""
        tree_frame = tk.Frame(self.window)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Configure tree columns based on mode
        self._setup_tree_columns(tree_frame)
        
        # Configure tree styles
        style = ttk.Style()
        style.configure('Treeview.Heading', font=self.theme.fonts['heading'])
        
        # Add scrollbars
        v_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.tree.yview)
        h_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.tree.xview)
        
        self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Pack tree and scrollbars
        self.tree.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew")
        
        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)
        
        # Bind double-click event
        self.tree.bind('<Double-1>', self._on_vulnerability_double_click)
    
    def _setup_tree_columns(self, parent: tk.Widget) -> None:
        """Setup tree view columns based on current mode."""
        if self.simple_mode:
            columns = ('severity', 'type', 'description', 'affected_servers', 'status')
            headings = ('Severity', 'Type', 'Description', 'Servers', 'Status')
            widths = (80, 120, 300, 80, 80)
        else:
            columns = ('severity', 'type', 'description', 'affected_servers', 'first_seen', 
                      'last_updated', 'status', 'cve_id', 'remediation')
            headings = ('Severity', 'Type', 'Description', 'Servers', 'First Seen', 
                       'Last Updated', 'Status', 'CVE ID', 'Remediation')
            widths = (80, 100, 250, 60, 100, 100, 80, 100, 150)
        
        self.tree = ttk.Treeview(parent, columns=columns, show='headings', height=20)
        
        for i, (col, heading, width) in enumerate(zip(columns, headings, widths)):
            self.tree.heading(col, text=heading, command=lambda c=col: self._sort_by_column(c))
            self.tree.column(col, width=width, minwidth=50)
    
    def _create_status_bar(self) -> None:
        """Create status bar with vulnerability counts."""
        status_frame = tk.Frame(self.window)
        status_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.status_label = self.theme.create_styled_label(
            status_frame,
            "Ready",
            "status"
        )
        self.status_label.pack(side=tk.LEFT)
        
        # Vulnerability count summary
        summary_frame = tk.Frame(status_frame)
        summary_frame.pack(side=tk.RIGHT)
        
        # These will be updated when data loads
        self.count_labels = {
            'critical': self.theme.create_styled_label(summary_frame, "Critical: 0", "status"),
            'high': self.theme.create_styled_label(summary_frame, "High: 0", "status"),
            'medium': self.theme.create_styled_label(summary_frame, "Medium: 0", "status"),
            'low': self.theme.create_styled_label(summary_frame, "Low: 0", "status"),
            'total': self.theme.create_styled_label(summary_frame, "Total: 0", "status")
        }
        
        for label in self.count_labels.values():
            label.pack(side=tk.LEFT, padx=10)
    
    def _setup_shortcuts(self) -> None:
        """Setup keyboard shortcuts."""
        self.window.bind('<Control-r>', lambda e: self._refresh_data())
        self.window.bind('<Control-e>', lambda e: self._show_export_menu())
        self.window.bind('<F1>', lambda e: self._toggle_mode())
        self.window.bind('<Escape>', lambda e: self.window.destroy())
    
    def _center_window(self) -> None:
        """Center window on parent."""
        self.window.update_idletasks()
        x = self.parent.winfo_x() + (self.parent.winfo_width() // 2) - (self.window.winfo_width() // 2)
        y = self.parent.winfo_y() + (self.parent.winfo_height() // 2) - (self.window.winfo_height() // 2)
        self.window.geometry(f"+{x}+{y}")
    
    def _load_vulnerabilities(self) -> None:
        """Load vulnerability data from database."""
        try:
            self.status_label.config(text="Loading vulnerabilities...")
            self.window.update()
            
            # Mock vulnerability data for development
            if hasattr(self.db_reader, 'mock_mode') and self.db_reader.mock_mode:
                self.vulnerabilities = self._generate_mock_vulnerabilities()
            else:
                # Query real database for vulnerabilities
                self.vulnerabilities = self._query_vulnerabilities()
            
            self._update_status_counts()
            self.status_label.config(text=f"Loaded {len(self.vulnerabilities)} vulnerabilities")
            
        except Exception as e:
            messagebox.showerror("Data Error", f"Failed to load vulnerability data:\n{str(e)}")
            self.vulnerabilities = []
    
    def _generate_mock_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Generate mock vulnerability data for testing."""
        mock_data = [
            {
                'id': 1,
                'severity': 'Critical',
                'type': 'Authentication',
                'description': 'SMB signing disabled - allows man-in-the-middle attacks',
                'affected_servers': 15,
                'first_seen': '2024-01-15',
                'last_updated': '2024-01-20',
                'status': 'Open',
                'cve_id': 'CVE-2023-1234',
                'remediation': 'Enable SMB signing in group policy',
                'details': 'SMB signing prevents tampering of SMB packets in transit...'
            },
            {
                'id': 2,
                'severity': 'High',
                'type': 'Authorization',
                'description': 'Anonymous access enabled on sensitive shares',
                'affected_servers': 8,
                'first_seen': '2024-01-10',
                'last_updated': '2024-01-18',
                'status': 'Investigating',
                'cve_id': '',
                'remediation': 'Disable anonymous access and require authentication',
                'details': 'Anonymous access allows unauthorized users to access shared resources...'
            },
            {
                'id': 3,
                'severity': 'Medium',
                'type': 'Information Disclosure',
                'description': 'SMB null session information disclosure',
                'affected_servers': 12,
                'first_seen': '2024-01-08',
                'last_updated': '2024-01-16',
                'status': 'Open',
                'cve_id': 'CVE-2022-5678',
                'remediation': 'Configure registry to restrict null session access',
                'details': 'Null sessions can be used to enumerate users and shares...'
            },
            {
                'id': 4,
                'severity': 'Low',
                'type': 'Misconfiguration',
                'description': 'Weak SMB protocol versions enabled',
                'affected_servers': 25,
                'first_seen': '2024-01-05',
                'last_updated': '2024-01-14',
                'status': 'Fixed',
                'cve_id': '',
                'remediation': 'Disable SMBv1 and enforce SMBv3',
                'details': 'Older SMB protocol versions have known security weaknesses...'
            }
        ]
        return mock_data
    
    def _query_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Query vulnerability data from database."""
        # This would query the actual database for vulnerability information
        # For now, return empty list as the database schema may not have vulnerability tracking yet
        return []
    
    def _apply_filters(self) -> None:
        """Apply current filters to vulnerability list."""
        self.filtered_vulnerabilities = []
        
        for vuln in self.vulnerabilities:
            if self._vulnerability_matches_filters(vuln):
                self.filtered_vulnerabilities.append(vuln)
        
        self._refresh_tree()
        self._update_status_counts()
    
    def _vulnerability_matches_filters(self, vuln: Dict[str, Any]) -> bool:
        """Check if vulnerability matches current filters."""
        # Severity filter
        if self.filter_vars['severity'].get() != 'All':
            if vuln['severity'] != self.filter_vars['severity'].get():
                return False
        
        # Status filter
        if self.filter_vars['status'].get() != 'All':
            if vuln['status'] != self.filter_vars['status'].get():
                return False
        
        # Type filter (advanced mode only)
        if not self.simple_mode and self.filter_vars['vulnerability_type'].get() != 'All':
            if vuln['type'] != self.filter_vars['vulnerability_type'].get():
                return False
        
        # Date filters (advanced mode only)
        if not self.simple_mode:
            date_from = self.filter_vars['date_from'].get()
            date_to = self.filter_vars['date_to'].get()
            
            if date_from and vuln['first_seen'] < date_from:
                return False
            if date_to and vuln['first_seen'] > date_to:
                return False
        
        return True
    
    def _refresh_tree(self) -> None:
        """Refresh tree view with filtered data."""
        # Clear existing items
        for item in self.tree.get_children():
            self.tree.delete(item)
        
        # Add filtered vulnerabilities
        for vuln in self.filtered_vulnerabilities:
            if self.simple_mode:
                values = (
                    vuln['severity'],
                    vuln['type'],
                    vuln['description'],
                    vuln['affected_servers'],
                    vuln['status']
                )
            else:
                values = (
                    vuln['severity'],
                    vuln['type'],
                    vuln['description'],
                    vuln['affected_servers'],
                    vuln['first_seen'],
                    vuln['last_updated'],
                    vuln['status'],
                    vuln['cve_id'],
                    vuln['remediation']
                )
            
            item_id = self.tree.insert('', 'end', values=values)
            
            # Color code by severity
            severity_colors = {
                'Critical': '#ffebee',
                'High': '#fff3e0', 
                'Medium': '#fffde7',
                'Low': '#f1f8e9'
            }
            if vuln['severity'] in severity_colors:
                self.tree.set(item_id, 'severity', vuln['severity'])
    
    def _update_status_counts(self) -> None:
        """Update status bar with vulnerability counts."""
        counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'total': 0}
        
        for vuln in self.filtered_vulnerabilities:
            severity = vuln['severity'].lower()
            if severity in counts:
                counts[severity] += 1
            counts['total'] += 1
        
        # Update labels with color coding
        for severity, count in counts.items():
            if severity != 'total':
                color = self.theme.get_severity_color(severity)
                self.count_labels[severity].config(
                    text=f"{severity.title()}: {count}",
                    fg=color
                )
            else:
                self.count_labels[severity].config(text=f"Total: {count}")
    
    def _on_filter_change(self, event=None) -> None:
        """Handle filter change events."""
        self._apply_filters()
    
    def _apply_quick_filter(self, filter_type: str) -> None:
        """Apply quick filter presets."""
        if filter_type == 'Critical':
            self.filter_vars['severity'].set('Critical')
        elif filter_type == 'Open':
            self.filter_vars['status'].set('Open')
        
        self._apply_filters()
    
    def _clear_filters(self) -> None:
        """Clear all filters."""
        for var in self.filter_vars.values():
            var.set('All' if var in [self.filter_vars['severity'], self.filter_vars['status'], 
                                    self.filter_vars['vulnerability_type']] else '')
        self._apply_filters()
    
    def _toggle_mode(self) -> None:
        """Toggle between simple and advanced modes."""
        self.simple_mode = not self.simple_mode
        
        # Update mode button text
        mode_text = "Simple Mode" if not self.simple_mode else "Advanced Mode"
        self.mode_button.config(text=mode_text)
        
        # Show/hide advanced filters
        if self.simple_mode:
            self.advanced_frame.pack_forget()
        else:
            self.advanced_frame.pack(fill=tk.X, padx=5, pady=(0, 5))
        
        # Recreate tree with appropriate columns
        tree_parent = self.tree.master
        self.tree.destroy()
        self._setup_tree_columns(tree_parent)
        
        # Re-add scrollbars
        v_scrollbar = ttk.Scrollbar(tree_parent, orient=tk.VERTICAL, command=self.tree.yview)
        h_scrollbar = ttk.Scrollbar(tree_parent, orient=tk.HORIZONTAL, command=self.tree.xview)
        
        self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        self.tree.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew")
        
        # Refresh data
        self._refresh_tree()
        
        # Bind double-click event again
        self.tree.bind('<Double-1>', self._on_vulnerability_double_click)
    
    def _sort_by_column(self, column: str) -> None:
        """Sort vulnerabilities by column."""
        reverse = getattr(self, f'_sort_{column}_reverse', False)
        
        if column == 'severity':
            # Custom severity sorting
            severity_order = {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}
            self.filtered_vulnerabilities.sort(
                key=lambda x: severity_order.get(x['severity'], 4), 
                reverse=reverse
            )
        elif column == 'affected_servers':
            self.filtered_vulnerabilities.sort(
                key=lambda x: x['affected_servers'], 
                reverse=reverse
            )
        else:
            self.filtered_vulnerabilities.sort(
                key=lambda x: str(x.get(column, '')), 
                reverse=reverse
            )
        
        # Toggle sort direction for next click
        setattr(self, f'_sort_{column}_reverse', not reverse)
        
        self._refresh_tree()
    
    def _on_vulnerability_double_click(self, event) -> None:
        """Handle double-click on vulnerability for details."""
        selection = self.tree.selection()
        if selection:
            item = selection[0]
            values = self.tree.item(item, 'values')
            
            # Find the corresponding vulnerability data
            for vuln in self.filtered_vulnerabilities:
                if (values[0] == vuln['severity'] and 
                    values[2] == vuln['description']):
                    self._show_vulnerability_details(vuln)
                    break
    
    def _show_vulnerability_details(self, vulnerability: Dict[str, Any]) -> None:
        """Show detailed information about a vulnerability."""
        detail_window = tk.Toplevel(self.window)
        detail_window.title(f"Vulnerability Details - {vulnerability['description'][:50]}...")
        detail_window.geometry("600x500")
        detail_window.transient(self.window)
        
        # Create scrollable text widget
        frame = tk.Frame(detail_window)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        text_widget = tk.Text(frame, wrap=tk.WORD)
        scrollbar = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=text_widget.yview)
        text_widget.configure(yscrollcommand=scrollbar.set)
        
        # Format vulnerability details
        details_text = f"""Vulnerability Details

Severity: {vulnerability['severity']}
Type: {vulnerability['type']}
Status: {vulnerability['status']}
CVE ID: {vulnerability.get('cve_id', 'N/A')}

Description:
{vulnerability['description']}

Affected Servers: {vulnerability['affected_servers']}
First Seen: {vulnerability['first_seen']}
Last Updated: {vulnerability['last_updated']}

Remediation:
{vulnerability.get('remediation', 'No specific remediation provided')}

Additional Details:
{vulnerability.get('details', 'No additional details available')}
"""
        
        text_widget.insert(tk.END, details_text)
        text_widget.config(state=tk.DISABLED)
        
        text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Add close button
        close_button = tk.Button(
            detail_window, text="Close", 
            command=detail_window.destroy
        )
        close_button.pack(pady=10)
    
    def _show_export_menu(self) -> None:
        """Show export options menu."""
        menu = tk.Menu(self.window, tearoff=0)
        menu.add_command(label="Export as CSV", command=self._export_csv)
        menu.add_command(label="Export as JSON", command=self._export_json)
        menu.add_command(label="Export Summary Report", command=self._export_summary)
        
        # Show menu at mouse position
        try:
            menu.post(self.window.winfo_pointerx(), self.window.winfo_pointery())
        except tk.TclError:
            # Fallback if pointer position not available
            menu.post(self.window.winfo_rootx() + 50, self.window.winfo_rooty() + 50)
    
    def _export_csv(self) -> None:
        """Export vulnerabilities to CSV format."""
        if not self.filtered_vulnerabilities:
            messagebox.showwarning("No Data", "No vulnerabilities to export.")
            return
        
        filename = filedialog.asksaveasfilename(
            title="Export Vulnerabilities as CSV",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialfile=f"vulnerabilities_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        )
        
        if filename:
            try:
                with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                    fieldnames = ['severity', 'type', 'description', 'affected_servers', 
                                 'first_seen', 'last_updated', 'status', 'cve_id', 'remediation']
                    
                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                    writer.writeheader()
                    
                    for vuln in self.filtered_vulnerabilities:
                        row = {field: vuln.get(field, '') for field in fieldnames}
                        writer.writerow(row)
                
                messagebox.showinfo(
                    "Export Complete",
                    f"Successfully exported {len(self.filtered_vulnerabilities)} vulnerabilities to:\n{filename}"
                )
                
            except Exception as e:
                messagebox.showerror("Export Error", f"Failed to export CSV:\n{str(e)}")
    
    def _export_json(self) -> None:
        """Export vulnerabilities to JSON format."""
        if not self.filtered_vulnerabilities:
            messagebox.showwarning("No Data", "No vulnerabilities to export.")
            return
        
        filename = filedialog.asksaveasfilename(
            title="Export Vulnerabilities as JSON",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            initialfile=f"vulnerabilities_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        )
        
        if filename:
            try:
                export_data = {
                    'export_timestamp': datetime.now().isoformat(),
                    'total_vulnerabilities': len(self.filtered_vulnerabilities),
                    'filters_applied': {k: v.get() for k, v in self.filter_vars.items()},
                    'vulnerabilities': self.filtered_vulnerabilities
                }
                
                with open(filename, 'w', encoding='utf-8') as jsonfile:
                    json.dump(export_data, jsonfile, indent=2)
                
                messagebox.showinfo(
                    "Export Complete",
                    f"Successfully exported {len(self.filtered_vulnerabilities)} vulnerabilities to:\n{filename}"
                )
                
            except Exception as e:
                messagebox.showerror("Export Error", f"Failed to export JSON:\n{str(e)}")
    
    def _export_summary(self) -> None:
        """Export vulnerability summary report."""
        if not self.filtered_vulnerabilities:
            messagebox.showwarning("No Data", "No vulnerabilities to export summary for.")
            return
        
        filename = filedialog.asksaveasfilename(
            title="Export Vulnerability Summary",
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
            initialfile=f"vulnerability_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        )
        
        if filename:
            try:
                # Generate summary statistics
                severity_counts = {}
                status_counts = {}
                type_counts = {}
                
                for vuln in self.filtered_vulnerabilities:
                    severity_counts[vuln['severity']] = severity_counts.get(vuln['severity'], 0) + 1
                    status_counts[vuln['status']] = status_counts.get(vuln['status'], 0) + 1
                    type_counts[vuln['type']] = type_counts.get(vuln['type'], 0) + 1
                
                with open(filename, 'w', encoding='utf-8') as txtfile:
                    txtfile.write("SMBSeek Vulnerability Summary Report\n")
                    txtfile.write("=" * 50 + "\n\n")
                    txtfile.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    txtfile.write(f"Total Vulnerabilities: {len(self.filtered_vulnerabilities)}\n\n")
                    
                    txtfile.write("Severity Distribution:\n")
                    for severity in ['Critical', 'High', 'Medium', 'Low']:
                        count = severity_counts.get(severity, 0)
                        txtfile.write(f"  {severity}: {count}\n")
                    
                    txtfile.write("\nStatus Distribution:\n")
                    for status, count in status_counts.items():
                        txtfile.write(f"  {status}: {count}\n")
                    
                    txtfile.write("\nVulnerability Type Distribution:\n")
                    for vuln_type, count in type_counts.items():
                        txtfile.write(f"  {vuln_type}: {count}\n")
                    
                    txtfile.write("\n" + "=" * 50 + "\n")
                    txtfile.write("Detailed Vulnerability List:\n\n")
                    
                    for i, vuln in enumerate(self.filtered_vulnerabilities, 1):
                        txtfile.write(f"{i}. {vuln['description']}\n")
                        txtfile.write(f"   Severity: {vuln['severity']}, Status: {vuln['status']}\n")
                        txtfile.write(f"   Affected Servers: {vuln['affected_servers']}\n")
                        if vuln.get('cve_id'):
                            txtfile.write(f"   CVE: {vuln['cve_id']}\n")
                        txtfile.write(f"   Remediation: {vuln.get('remediation', 'Not specified')}\n\n")
                
                messagebox.showinfo(
                    "Export Complete",
                    f"Successfully exported vulnerability summary to:\n{filename}"
                )
                
            except Exception as e:
                messagebox.showerror("Export Error", f"Failed to export summary:\n{str(e)}")
    
    def _refresh_data(self) -> None:
        """Refresh vulnerability data from database."""
        self._load_vulnerabilities()
        self._apply_filters()