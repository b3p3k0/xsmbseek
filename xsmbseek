#!/usr/bin/env python3
"""
xsmbseek - GUI Frontend for SMBSeek Security Toolkit

A cross-platform graphical interface for the SMBSeek security toolkit.
Provides mission control dashboard with drill-down capabilities for detailed analysis.

This is a standalone frontend that works with SMBSeek as an external dependency.

Usage:
    xsmbseek [--mock] [--config CONFIG_FILE] [--smbseek-path PATH] [--database-path PATH]

Requirements:
    - SMBSeek toolkit (https://github.com/b3p3k0/smbseek)
    - Python 3.6+
    - tkinter (usually included with Python)

Author: xsmbseek development team
Version: 1.0.0
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import argparse
import sys
import os
import json
from pathlib import Path
import threading
import queue
import webbrowser
from typing import Dict, Any, Optional

# Ensure we're working with absolute paths regardless of where user runs the script
SCRIPT_DIR = Path(__file__).parent.absolute()
GUI_DIR = SCRIPT_DIR / "gui"

# Canonical window sizing for the xsmbseek frontend
WINDOW_WIDTH = 1200
WINDOW_HEIGHT = 745
WINDOW_GEOMETRY = f"{WINDOW_WIDTH}x{WINDOW_HEIGHT}"

# Add GUI components and utils to path
sys.path.insert(0, str(GUI_DIR / "components"))
sys.path.insert(0, str(GUI_DIR / "utils"))

# Configuration manager for xsmbseek settings
class XSMBSeekConfig:
    """Manages xsmbseek configuration separate from SMBSeek configuration."""
    
    def __init__(self, config_file: Optional[str] = None):
        """
        Initialize configuration manager.
        
        Args:
            config_file: Optional path to specific config file
        """
        self.config_file = config_file or (SCRIPT_DIR / "xsmbseek-config.json")
        self.config = self._load_config()
    
    def _load_config(self) -> Dict[str, Any]:
        """Load configuration with fallback to defaults."""
        # Try specified config file first
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    config = json.load(f)
                    return self._validate_and_migrate_config(config)
            except (json.JSONDecodeError, FileNotFoundError) as e:
                print(f"Warning: Failed to load config from {self.config_file}: {e}")
        
        # Try default config file
        default_config = SCRIPT_DIR / "xsmbseek-config.json"
        if default_config.exists() and default_config != self.config_file:
            try:
                with open(default_config, 'r') as f:
                    config = json.load(f)
                    print(f"Using default configuration from {default_config}")
                    return self._validate_and_migrate_config(config)
            except (json.JSONDecodeError, FileNotFoundError):
                pass
        
        # Fall back to built-in defaults
        return self._get_default_config()
    
    def _get_default_config(self) -> Dict[str, Any]:
        """Get built-in default configuration."""
        return {
            "smbseek": {
                "path": "./smbseek",
                "database_path": None
            },
            "gui": {
                "theme": "default",
                "interface_mode": "simple",
                "last_used_config": None
            },
            "app": {
                "version": "1.0.0",
                "first_run": True,
                "github_repo": "https://github.com/b3p3k0/smbseek"
            }
        }
    
    def _validate_and_migrate_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Validate and migrate configuration to current version."""
        defaults = self._get_default_config()
        
        # Ensure all required sections exist
        for section in defaults:
            if section not in config:
                config[section] = defaults[section]
            else:
                # Ensure all keys in each section exist
                for key in defaults[section]:
                    if key not in config[section]:
                        config[section][key] = defaults[section][key]
        
        return config
    
    def save_config(self) -> bool:
        """Save current configuration to file."""
        try:
            # Ensure directory exists
            self.config_file.parent.mkdir(parents=True, exist_ok=True)
            
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
            return True
        except Exception as e:
            print(f"Error saving config: {e}")
            return False
    
    def get_smbseek_path(self) -> Path:
        """Get absolute path to SMBSeek installation."""
        path_str = self.config["smbseek"]["path"]
        path = Path(path_str)
        
        if path.is_absolute():
            return path
        else:
            # Resolve relative to script location, not current working directory
            return (SCRIPT_DIR / path).resolve()
    
    def set_smbseek_path(self, path: str) -> None:
        """Set SMBSeek installation path."""
        self.config["smbseek"]["path"] = path
    
    def get_database_path(self) -> Optional[Path]:
        """Get database path, with fallback to SMBSeek default."""
        db_path = self.config["smbseek"]["database_path"]
        if db_path:
            path = Path(db_path)
            return path if path.is_absolute() else (SCRIPT_DIR / path).resolve()
        else:
            # Default to smbseek/smbseek.db
            return self.get_smbseek_path() / "smbseek.db"
    
    def set_database_path(self, path: Optional[str]) -> None:
        """Set database path (None for default)."""
        self.config["smbseek"]["database_path"] = path
    
    def validate_smbseek_installation(self) -> Dict[str, Any]:
        """
        Validate SMBSeek installation at configured path.
        
        Returns:
            Dict with 'valid' bool and 'error' message if invalid
        """
        smbseek_path = self.get_smbseek_path()
        
        if not smbseek_path.exists():
            return {
                'valid': False,
                'error': f"SMBSeek directory not found at: {smbseek_path}"
            }
        
        # Check for main smbseek.py script
        main_script = smbseek_path / "smbseek.py"
        if not main_script.exists():
            return {
                'valid': False,
                'error': f"SMBSeek main script not found at: {main_script}"
            }
        
        # Check for essential directories
        required_dirs = ["commands", "shared", "tools"]
        missing_dirs = []
        for dir_name in required_dirs:
            if not (smbseek_path / dir_name).exists():
                missing_dirs.append(dir_name)
        
        if missing_dirs:
            return {
                'valid': False,
                'error': f"Missing required directories: {', '.join(missing_dirs)}"
            }
        
        return {'valid': True}


def show_smbseek_setup_dialog(parent=None, current_path: str = "./smbseek") -> Optional[str]:
    """
    Show dialog for setting up SMBSeek path.
    
    Args:
        parent: Parent window
        current_path: Current configured path
        
    Returns:
        Selected path or None if cancelled
    """
    dialog = tk.Toplevel(parent) if parent else tk.Tk()
    dialog.title("SMBSeek Setup Required")
    dialog.geometry("600x400")
    dialog.resizable(True, True)
    
    if parent:
        # Center on parent
        dialog.transient(parent)
        dialog.grab_set()
    
    result = None
    
    def on_browse():
        """Browse for SMBSeek directory."""
        path = filedialog.askdirectory(
            title="Select SMBSeek Installation Directory",
            initialdir=current_path if os.path.exists(current_path) else "."
        )
        if path:
            path_var.set(path)
    
    def on_github():
        """Open SMBSeek GitHub repository."""
        webbrowser.open("https://github.com/b3p3k0/smbseek")
    
    def on_ok():
        """Validate and accept the selected path."""
        nonlocal result
        path = path_var.get().strip()
        if not path:
            messagebox.showerror("Error", "Please specify a path to SMBSeek")
            return
        
        # Validate the path
        config = XSMBSeekConfig()
        config.set_smbseek_path(path)
        validation = config.validate_smbseek_installation()
        
        if not validation['valid']:
            messagebox.showerror("Invalid SMBSeek Installation", validation['error'])
            return
        
        result = path
        dialog.destroy()
    
    def on_cancel():
        """Cancel setup."""
        nonlocal result
        result = None
        dialog.destroy()
    
    # Header
    header_frame = ttk.Frame(dialog)
    header_frame.pack(fill="x", padx=20, pady=(20, 10))
    
    ttk.Label(
        header_frame,
        text="SMBSeek Installation Required",
        font=("TkDefaultFont", 12, "bold")
    ).pack(anchor="w")
    
    ttk.Label(
        header_frame,
        text="xsmbseek requires the SMBSeek security toolkit to function.",
        wraplength=550
    ).pack(anchor="w", pady=(5, 0))
    
    # Instructions
    instructions_frame = ttk.LabelFrame(dialog, text="Setup Instructions", padding=10)
    instructions_frame.pack(fill="x", padx=20, pady=10)
    
    instructions = [
        "1. If you haven't installed SMBSeek yet:",
        "   • Click 'Open SMBSeek Repository' below",
        "   • Follow the installation instructions",
        "   • Come back to this dialog",
        "",
        "2. If SMBSeek is already installed:",
        "   • Enter the path to your SMBSeek directory below",
        "   • Or click 'Browse' to select the directory",
        "   • The directory should contain 'smbseek.py'"
    ]
    
    for instruction in instructions:
        ttk.Label(instructions_frame, text=instruction, justify="left").pack(anchor="w")
    
    # Path selection
    path_frame = ttk.LabelFrame(dialog, text="SMBSeek Path", padding=10)
    path_frame.pack(fill="x", padx=20, pady=10)
    
    path_var = tk.StringVar(value=current_path)
    
    path_entry_frame = ttk.Frame(path_frame)
    path_entry_frame.pack(fill="x")
    
    ttk.Entry(path_entry_frame, textvariable=path_var).pack(side="left", fill="x", expand=True)
    ttk.Button(path_entry_frame, text="Browse", command=on_browse).pack(side="right", padx=(5, 0))
    
    # Buttons
    button_frame = ttk.Frame(dialog)
    button_frame.pack(fill="x", padx=20, pady=(10, 20))
    
    ttk.Button(
        button_frame,
        text="Open SMBSeek Repository",
        command=on_github
    ).pack(side="left")
    
    ttk.Button(button_frame, text="Cancel", command=on_cancel).pack(side="right")
    ttk.Button(button_frame, text="OK", command=on_ok).pack(side="right", padx=(0, 5))
    
    # Handle window closing
    dialog.protocol("WM_DELETE_WINDOW", on_cancel)
    
    # Wait for result
    dialog.wait_window(dialog)
    
    return result


# Import GUI components (these need to be imported after path setup)
try:
    from dashboard import DashboardWidget
    from server_list_window import open_server_list_window, ServerListWindow
    from config_editor_window import open_config_editor_window
    from app_config_dialog import open_app_config_dialog
    from data_import_dialog import open_data_import_dialog
    from database_setup_dialog import show_database_setup_dialog
    from database_access import DatabaseReader
    from backend_interface import BackendInterface
    from style import get_theme, apply_theme_to_window
    from settings_manager import get_settings_manager
except ImportError as e:
    print(f"Error importing GUI components: {e}")
    print("Make sure the gui/ directory exists and contains all required components.")
    sys.exit(1)


class XSMBSeekGUI:
    """
    Main xsmbseek GUI application.
    
    Coordinates between dashboard, backend interface, and drill-down windows.
    Handles application lifecycle, error recovery, and user interactions.
    
    This version works with SMBSeek as an external configurable dependency.
    """
    
    def __init__(self, mock_mode: bool = False, config_path: Optional[str] = None, 
                 smbseek_path: Optional[str] = None, database_path: Optional[str] = None):
        """
        Initialize xsmbseek GUI application.
        
        Args:
            mock_mode: Whether to use mock data for testing
            config_path: Optional path to xsmbseek configuration file
            smbseek_path: Optional path to SMBSeek installation
            database_path: Optional path to database file
        """
        self.mock_mode = mock_mode
        
        # Initialize configuration system
        # Configuration Architecture:
        # - self.config (XSMBSeekConfig) manages xsmbseek-config.json 
        # - self.settings_manager (SettingsManager) manages ~/.smbseek/gui_settings.json
        # These work together but maintain separate responsibilities
        self.config = XSMBSeekConfig(config_path)
        
        # Override config with CLI arguments if provided
        if smbseek_path:
            self.config.set_smbseek_path(smbseek_path)
        if database_path:
            self.config.set_database_path(database_path)
        
        # GUI state
        self.root = None
        self.dashboard = None
        self.drill_down_windows = {}
        
        # Backend interfaces
        self.db_reader = None
        self.backend_interface = None
        self.settings_manager = None
        
        # Threading for background operations
        self.scan_thread = None
        self.scan_queue = queue.Queue()
        
        self._initialize_application()
        
        # Set up global exception handler
        self._setup_global_exception_handler()
    
    def _setup_global_exception_handler(self) -> None:
        """Set up global exception handler for unhandled errors."""
        def handle_exception(exc_type, exc_value, exc_traceback):
            # Don't catch KeyboardInterrupt (Ctrl+C)
            if issubclass(exc_type, KeyboardInterrupt):
                sys.__excepthook__(exc_type, exc_value, exc_traceback)
                return
            
            error_msg = f"Unhandled error: {exc_type.__name__}: {exc_value}"
            
            try:
                # Try to show GUI error dialog
                messagebox.showerror(
                    "Unexpected Error",
                    f"An unexpected error occurred:\\n\\n{error_msg}\\n\\n"
                    "The application may continue to work, but you should save your work "
                    "and restart if you experience issues.\\n\\n"
                    "Please report this error if it persists."
                )
            except:
                # Fall back to console
                print(f"CRITICAL ERROR: {error_msg}")
                import traceback
                traceback.print_exception(exc_type, exc_value, exc_traceback)
        
        # Install the handler
        sys.excepthook = handle_exception
    
    def _initialize_application(self) -> None:
        """Initialize all application components."""
        try:
            self._setup_smbseek_integration()
            self._create_main_window()
            self._create_dashboard()
            self._setup_event_handlers()
            
            if self.mock_mode:
                self._enable_mock_mode()
            
        except Exception as e:
            self._handle_initialization_error(e)
    
    def _setup_smbseek_integration(self) -> None:
        """
        Setup integration with SMBSeek toolkit.
        
        Initializes two separate configuration systems:
        1. XSMBSeekConfig: Manages xsmbseek-config.json (SMBSeek paths, app settings)
        2. SettingsManager: Manages ~/.smbseek/gui_settings.json (GUI preferences)
        
        The systems work together but maintain separate concerns for modularity.
        XSMBSeekConfig handles application-level configuration while SettingsManager
        handles user preferences and GUI state.
        """
        # Validate SMBSeek installation
        validation = self.config.validate_smbseek_installation()
        
        if not validation['valid']:
            # Show setup dialog
            new_path = show_smbseek_setup_dialog(
                current_path=str(self.config.get_smbseek_path())
            )
            
            if new_path is None:
                # User cancelled setup
                print("SMBSeek setup cancelled. Exiting.")
                sys.exit(0)
            
            # Update configuration with new path
            self.config.set_smbseek_path(new_path)
            self.config.save_config()
            
            # Re-validate
            validation = self.config.validate_smbseek_installation()
            if not validation['valid']:
                raise RuntimeError(f"SMBSeek validation failed after setup: {validation['error']}")
        
        # Initialize backend interface with configured path
        try:
            self.backend_interface = BackendInterface(str(self.config.get_smbseek_path()))
        except Exception as e:
            raise RuntimeError(f"Failed to initialize SMBSeek interface: {e}")
        
        # Initialize database reader
        try:
            db_path = self.config.get_database_path()
            self.db_reader = DatabaseReader(str(db_path))
        except Exception as e:
            raise RuntimeError(f"Failed to initialize database reader: {e}")
        
        # Initialize settings manager (GUI preferences in ~/.smbseek/)
        # Note: This is separate from self.config (XSMBSeekConfig) which manages xsmbseek-config.json
        try:
            self.settings_manager = get_settings_manager()  # Use default ~/.smbseek/ directory
            
            # Sync SMBSeek path from XSMBSeekConfig to SettingsManager for GUI consistency
            smbseek_path = str(self.config.get_smbseek_path())
            self.settings_manager.set_backend_path(smbseek_path)
            
        except Exception as e:
            raise RuntimeError(f"Failed to initialize settings manager: {e}")
    
    def _create_main_window(self) -> None:
        """Create and configure main application window."""
        self.root = tk.Tk()
        self.root.title("xsmbseek - SMBSeek GUI Frontend")
        
        # Force canonical geometry; users may enlarge but not shrink below this
        self.root.geometry(WINDOW_GEOMETRY)
        self.root.minsize(WINDOW_WIDTH, WINDOW_HEIGHT)
        
        # Apply theme
        apply_theme_to_window(self.root)
        
        # Configure window behavior
        self.root.protocol("WM_DELETE_WINDOW", self._on_closing)
        
        # Center window on screen
        self._center_window()
        
        # Update window title to show SMBSeek path
        smbseek_path = self.config.get_smbseek_path()
        self.root.title(f"xsmbseek - SMBSeek GUI Frontend ({smbseek_path.name})")
    
    def _center_window(self) -> None:
        """
        Center the main window on screen using fixed dimensions.
        
        Forces window to maintain intended 1200x745 size instead of
        auto-sizing based on content. This ensures consistent compact
        layout across different screen configurations.
        
        Design Decision: Fixed dimensions prevent tkinter's automatic
        content-based sizing from overriding our intended compact layout.
        """
        # Force our intended dimensions instead of querying auto-sized dimensions
        # This prevents tkinter from expanding the window based on content
        target_width = WINDOW_WIDTH
        target_height = WINDOW_HEIGHT
        
        # Calculate center position based on intended dimensions
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        x = (screen_width // 2) - (target_width // 2)
        y = (screen_height // 2) - (target_height // 2)
        
        # Force our intended dimensions and center position
        self.root.geometry(f"{target_width}x{target_height}+{x}+{y}")
    
    def _enforce_window_size(self) -> None:
        """
        Enforce minimum window size constraints while respecting user preferences.
        
        This method ensures the window doesn't shrink below minimum requirements
        but allows users to manually resize larger without forcing back to defaults.
        Implements industry-standard UX behavior for window management.
        """
        min_width = WINDOW_WIDTH
        min_height = WINDOW_HEIGHT
        
        # Get current geometry
        current_geometry = self.root.geometry()
        if 'x' in current_geometry and '+' in current_geometry:
            # Parse current dimensions and position
            size_part = current_geometry.split('+')[0]
            pos_part = current_geometry[len(size_part):]
            
            current_width, current_height = map(int, size_part.split('x'))
            
            # Only enforce minimum constraints - respect user's larger choices
            needs_adjustment = False
            new_width = current_width
            new_height = current_height
            
            if current_width < min_width:
                new_width = min_width
                needs_adjustment = True
                
            if current_height < min_height:
                new_height = min_height
                needs_adjustment = True
            
            # Only adjust if window is below minimum - preserve user's larger sizing
            if needs_adjustment:
                self.root.geometry(f"{new_width}x{new_height}{pos_part}")
        else:
            # Fallback: ensure minimum size without forcing position
            self.root.minsize(min_width, min_height)
    
    def _create_dashboard(self) -> None:
        """Create main dashboard widget."""
        # Get correct SMBSeek config path
        smbseek_config_path = self.config.get_smbseek_path() / "conf" / "config.json"
        
        self.dashboard = DashboardWidget(
            self.root,
            self.db_reader,
            self.backend_interface,
            str(smbseek_config_path)
        )
        
        # Set callbacks
        self.dashboard.set_drill_down_callback(self._open_drill_down_window)
        self.dashboard.set_config_editor_callback(self._open_config_editor_direct)
        self.dashboard.set_size_enforcement_callback(self._enforce_window_size)
    
    def _setup_event_handlers(self) -> None:
        """Setup application-wide event handlers."""
        # Keyboard shortcuts
        self.root.bind("<Control-q>", lambda e: self._on_closing())
        self.root.bind("<F5>", lambda e: self._refresh_dashboard())
        self.root.bind("<Control-r>", lambda e: self._refresh_dashboard())
        self.root.bind("<Control-i>", lambda e: self._open_drill_down_window("data_import", {}))
        self.root.bind("<Control-comma>", lambda e: self._open_xsmbseek_settings())
        
        # Handle scan queue updates
        self._process_scan_queue()
    
    def _enable_mock_mode(self) -> None:
        """Enable mock mode for testing."""
        self.db_reader.enable_mock_mode()
        self.backend_interface.enable_mock_mode()
        self.dashboard.enable_mock_mode()
        
        # Update window title to indicate mock mode
        current_title = self.root.title()
        self.root.title(f"{current_title} - Mock Mode")
    
    def _handle_initialization_error(self, error: Exception) -> None:
        """Handle application initialization errors."""
        error_message = f"Failed to initialize xsmbseek: {error}"
        
        # Try to show error in GUI if possible
        try:
            root = tk.Tk()
            root.withdraw()  # Hide main window
            messagebox.showerror("Initialization Error", error_message)
            root.destroy()
        except:
            # Fall back to console output
            print(f"ERROR: {error_message}")
        
        sys.exit(1)
    
    def _open_xsmbseek_settings(self) -> None:
        """Open xsmbseek settings dialog."""
        # This will be implemented in Phase 3
        messagebox.showinfo(
            "Settings",
            "xsmbseek settings dialog will be implemented in the next phase.\\n\\n"
            "For now, you can edit xsmbseek-config.json manually."
        )
    
    def _open_drill_down_window(self, window_type: str, data: Dict[str, Any]) -> None:
        """
        Open drill-down window for detailed analysis.
        
        Args:
            window_type: Type of window to open
            data: Data to pass to the window
        """
        try:
            if window_type == "server_list":
                open_server_list_window(self.root, self.db_reader, data, self.settings_manager)
            elif window_type == "config_editor":
                # Open SMBSeek configuration editor
                config_path = self.config.get_smbseek_path() / "conf" / "config.json"
                open_config_editor_window(self.root, str(config_path))
            elif window_type == "app_config":
                # Open application configuration dialog
                open_app_config_dialog(
                    self.root,
                    self.settings_manager,
                    self._open_config_editor_direct,
                    self.config,  # Pass main config so changes get saved to xsmbseek-config.json
                    self._refresh_database_connection  # Refresh database connection after changes
                )
            elif window_type == "data_import":
                open_data_import_dialog(self.root, self.db_reader)
            elif window_type == "recent_activity":
                server_window = ServerListWindow(self.root, self.db_reader)
                server_window.apply_recent_discoveries_filter()
            else:
                # For other window types, show placeholder message
                window_titles = {
                    "share_details": "Share Access Details", 
                    "recent_activity": "Recent Activity Timeline",
                    "geographic_report": "Geographic Distribution",
                    "activity_timeline": "Activity Timeline",
                    "config_editor": "Configuration Editor",
                    "data_import": "Data Import",
                }
                
                title = window_titles.get(window_type, "Detail Window")
                
                messagebox.showinfo(
                    title,
                    f"Drill-down window '{title}' will be implemented in upcoming phases.\\n\\n"
                    f"This would show detailed information for: {window_type}"
                )
        except Exception as e:
            messagebox.showerror(
                "Window Error",
                f"Failed to open {window_type} window:\\n{str(e)}"
            )
    
    def _open_config_editor_direct(self, config_path: str) -> None:
        """
        Open configuration editor directly with specified path.
        
        Args:
            config_path: Path to configuration file to edit
        """
        try:
            open_config_editor_window(self.root, config_path)
        except Exception as e:
            messagebox.showerror(
                "Configuration Editor Error",
                f"Failed to open configuration editor:\\n{str(e)}"
            )
    
    def _refresh_dashboard(self) -> None:
        """Manually refresh dashboard data."""
        if self.dashboard:
            self.dashboard._refresh_dashboard_data()
    
    def _refresh_database_connection(self) -> None:
        """Refresh database connection after configuration changes."""
        try:
            # Reinitialize database reader with updated path
            db_path = self.config.get_database_path()
            self.db_reader = DatabaseReader(str(db_path))
            
            # Update dashboard with new database reader
            if self.dashboard:
                self.dashboard.db_reader = self.db_reader
                self.dashboard._refresh_dashboard_data()
                
        except Exception as e:
            messagebox.showerror(
                "Database Connection Error",
                f"Failed to connect to database at new path:\n{str(e)}\n\n"
                "Please check the database path in configuration."
            )
    
    def _process_scan_queue(self) -> None:
        """Process scan queue updates for progress display."""
        try:
            while True:
                update = self.scan_queue.get_nowait()
                if update["type"] == "progress":
                    self.dashboard.update_scan_progress(
                        update["percentage"],
                        update["message"]
                    )
                elif update["type"] == "complete":
                    self.dashboard.finish_scan_progress(
                        update["success"],
                        update["results"]
                    )
        except queue.Empty:
            pass
        
        # Schedule next check
        self.root.after(100, self._process_scan_queue)
    
    def _on_closing(self) -> None:
        """Handle application closing."""
        # Check for active scans
        if self.scan_thread and self.scan_thread.is_alive():
            response = messagebox.askyesno(
                "Scan in Progress",
                "A scan is currently running. Are you sure you want to exit?",
                icon="warning"
            )
            if not response:
                return
        
        # Persist any pending configuration changes (geometry is fixed by design)
        self.config.save_config()
        
        # Clean up and exit
        try:
            # Close any open drill-down windows
            for window in self.drill_down_windows.values():
                try:
                    window.destroy()
                except:
                    pass
            
            # Clean up backend interfaces
            if self.db_reader:
                self.db_reader.clear_cache()
            
        except Exception as e:
            print(f"Cleanup error: {e}")
        finally:
            self.root.destroy()
    
    def run(self) -> None:
        """Start the GUI application main loop."""
        try:
            self.root.mainloop()
        except KeyboardInterrupt:
            self._on_closing()
        except Exception as e:
            messagebox.showerror("Application Error", f"Unexpected error: {e}")
            self._on_closing()


def main():
    """Main entry point for xsmbseek GUI."""
    parser = argparse.ArgumentParser(
        prog='xsmbseek',
        description="xsmbseek - GUI Frontend for SMBSeek Security Toolkit",
        epilog="For more information, visit: https://github.com/b3p3k0/smbseek"
    )
    
    parser.add_argument(
        "--mock",
        action="store_true",
        help="Run in mock mode with test data (for development/testing)"
    )
    
    parser.add_argument(
        "--config",
        type=str,
        metavar="FILE",
        help="Path to xsmbseek configuration file (default: ./xsmbseek-config.json)"
    )
    
    parser.add_argument(
        "--smbseek-path",
        type=str,
        metavar="PATH",
        help="Path to SMBSeek installation directory (overrides config)"
    )
    
    parser.add_argument(
        "--database-path",
        type=str,
        metavar="PATH",
        help="Path to database file (overrides config)"
    )

    parser.add_argument(
        "--debug",
        action="store_true",
        help="Enable debug output"
    )

    parser.add_argument(
        "--version",
        action="version",
        version="xsmbseek 1.0.0"
    )
    
    args = parser.parse_args()

    # Set debug environment variable if requested
    if args.debug:
        os.environ["XSMBSEEK_DEBUG_SUBPROCESS"] = "1"

    try:
        app = XSMBSeekGUI(
            mock_mode=args.mock,
            config_path=args.config,
            smbseek_path=getattr(args, 'smbseek_path', None),
            database_path=getattr(args, 'database_path', None)
        )
        app.run()
    except KeyboardInterrupt:
        print("\\nApplication interrupted by user")
        sys.exit(0)
    except Exception as e:
        print(f"Fatal error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
